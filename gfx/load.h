/* Generated with shader-compressor by NR4/Team210. */
#ifndef LOAD_H
#define LOAD_H
const char * load_frag =
"/* Fuer Elite - 64k Intro by Team210 at Underground Conference 9\n"
" * Copyright (C) 2019  Alexander Kraus <nr4@z10.info>\n"
" * \n"
" * This program is free software: you can redistribute it and/or modify\n"
" * it under the terms of the GNU General Public License as published by\n"
" * the Free Software Foundation, either version 3 of the License, or\n"
" * (at your option) any later version.\n"
" * \n"
" * This program is distributed in the hope that it will be useful,\n"
" * but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
" * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
" * GNU General Public License for more details.\n"
" * \n"
" * You should have received a copy of the GNU General Public License\n"
" * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n"
" */\n"
"\n"
"#version 130\n"
"\n"
"uniform float iTime, iProgress;\n"
"uniform vec2 iResolution;\n"
"\n"
"// Global constants\n"
"const float pi = acos(-1.);\n"
"const vec3 c = vec3(1.0, 0.0, -1.0);\n"
"float a = 1.0;\n"
"\n"
"void rand(in vec2 x, out float n)\n"
"{\n"
"    x += 400.;\n"
"    n = fract(sin(dot(sign(x)*abs(x) ,vec2(12.9898,78.233)))*43758.5453);\n"
"}\n"
"\n"
"void lfnoise(in vec2 t, out float n)\n"
"{\n"
"    vec2 i = floor(t);\n"
"    t = fract(t);\n"
"    t = smoothstep(c.yy, c.xx, t);\n"
"    vec2 v1, v2;\n"
"    rand(i, v1.x);\n"
"    rand(i+c.xy, v1.y);\n"
"    rand(i+c.yx, v2.x);\n"
"    rand(i+c.xx, v2.y);\n"
"    v1 = c.zz+2.*mix(v1, v2, t.y);\n"
"    n = mix(v1.x, v1.y, t.x);\n"
"}\n"
"\n"
"// Stroke\n"
"void stroke(in float d0, in float s, out float d)\n"
"{\n"
"    d = abs(d0)-s;\n"
"}\n"
"\n"
"float sm(float d)\n"
"{\n"
"    return step(d,0.);\n"
"//    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n"
"}\n"
"\n"
"void dcirclesegment(in vec2 x, in float R, in float p0, in float p1, out float d)\n"
"{\n"
"    float p = atan(x.y, x.x);\n"
"    vec2 philo = vec2(max(p0, p1), min(p0, p1));\n"
"    if((p < philo.x && p > philo.y) || (p+2.0*pi < philo.x && p+2.0*pi > philo.y) || (p-2.0*pi < philo.x && p-2.0*pi > philo.y))\n"
"        d = abs(length(x)-R);\n"
"    else d = min(\n"
"        length(x-vec2(cos(p0), sin(p0))),\n"
"        length(x-vec2(cos(p1), sin(p1)))\n"
"        );\n"
"}\n"
"\n"
"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n"
"{\n"
"    a = iResolution.x/iResolution.y;\n"
"    \n"
"    vec2 uv = fragCoord/iResolution.yy-0.5*vec2(a, 1.0), \n"
"        s;\n"
"    \n"
"    // background\n"
"    vec3 col = c.yyy,\n"
"        o = c.yzx,\n"
"        r = c.xyy, \n"
"        u = cross(r,normalize(o)),\n"
"        t = uv.x * r + uv.y * u,\n"
"        dir = normalize(t-o),\n"
"        size,\n"
"        x,\n"
"        n;\n"
"    \n"
"    // Floor\n"
"    float d = -(o.z-.35)/dir.z,\n"
"        da;\n"
"    vec2 y = (o + d * dir).xy;\n"
"    d = length(y)-.3;\n"
"    stroke(d, .04, d);\n"
"    float p = atan(y.y, y.x);\n"
"    p = mod(p, pi/8.)-.5*pi/8.;\n"
"    d = mix(d, 1., sm(p));\n"
"    col = mix(col, vec3(0.81,0.15,0.18), sm(d));\n"
"    stroke(d, .005, da);\n"
"    col = mix(col, vec3(0.04,0.18,0.24), sm(da));\n"
"    stroke(d-.01, .0025, d);\n"
"    col = mix(col, vec3(0.81,0.15,0.18), sm(d));\n"
"    \n"
"    // Layer above\n"
"    d = -(o.z-.3)/dir.z;\n"
"    y = (o + d * dir).xy;\n"
"    d = length(y)-.3;\n"
"    stroke(d, .04, d);\n"
"    p = atan(y.y, y.x);\n"
"    p = mod(p, pi/8.)-.5*pi/8.;\n"
"    d = mix(d, 1., sm(p));\n"
"    stroke(d, .0035, d);\n"
"    col = mix(col, vec3(0.85,0.87,0.89), sm(d));\n"
"    \n"
"    // Progress\n"
"    d = -(o.z-.3)/dir.z;\n"
"    y = (o + d * dir).xy;\n"
"    dcirclesegment(y, .3, -pi, mix(-pi, pi, iProgress), d);\n"
"    stroke(d, .03, d);\n"
"    col = mix(col, mix(col, 1.5*vec3(0.85,0.87,0.89), .8), sm(d));\n"
"    stroke(d, .0035, d);\n"
"    col = mix(col, mix(col, vec3(0.04,0.18,0.24), .5), sm(d));\n"
"    \n"
"    // dots above\n"
"    for(float i=-.1; i>-.8; i-= .01)\n"
"    {\n"
"        d = -(o.z-.25-i)/dir.z;\n"
"        y = (o + d * dir).xy;\n"
"        float n;\n"
"        p = atan(y.y, y.x);\n"
"        lfnoise(vec2(i,p), n);\n"
"        d = length(y)-.3+n;\n"
"        stroke(d, .04, d);\n"
"        \n"
"        float pp = pi/(32.*(-i));\n"
"        p = mod(p, pp)-.5*pp;\n"
"        d = mix(d, 1., sm(p));\n"
"        stroke(d, .017, d);\n"
"        col = mix(col, mix(col, mix(col,vec3(0.81,0.15,0.18),step(atan(y.y,y.x)-p,mix(-pi,pi,iProgress))) , .2), sm(d));\n"
"        stroke(d, .005, d);\n"
"        col = mix(col, mix(col, mix(col,vec3(0.04,0.18,0.24),step(atan(y.y,y.x)-p,mix(-pi,pi,iProgress))) , .2), sm(d));\n"
"        \n"
"    }\n"
"    \n"
"    vec2 ff = abs(mod(uv,.1)-.05)-.0005;\n"
"    col = mix(col, vec3(.7,.11,.42), sm(min(ff.x,ff.y)));\n"
"    ff = abs(mod(uv-.0005,.1)-.05)-.0005;\n"
"    col = mix(col, c.xxx, sm(min(ff.x,ff.y)));\n"
"    \n"
"    fragColor = vec4(clamp(col,0.,1.),1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    mainImage(gl_FragColor, gl_FragCoord.xy);\n"
"}\n"
"\n"
;
#endif
