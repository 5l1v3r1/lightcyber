/* Generated with shader-compressor by NR4/Team210. */
#ifndef LOAD_H
#define LOAD_H
const char * load_frag =
"/* Fuer Elite - 64k Intro by Team210 at Underground Conference 9\n"
" * Copyright (C) 2019  Alexander Kraus <nr4@z10.info>\n"
" * \n"
" * This program is free software: you can redistribute it and/or modify\n"
" * it under the terms of the GNU General Public License as published by\n"
" * the Free Software Foundation, either version 3 of the License, or\n"
" * (at your option) any later version.\n"
" * \n"
" * This program is distributed in the hope that it will be useful,\n"
" * but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
" * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
" * GNU General Public License for more details.\n"
" * \n"
" * You should have received a copy of the GNU General Public License\n"
" * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n"
" */\n"
"\n"
"#version 130\n"
"\n"
"uniform float iTime, iProgress;\n"
"uniform vec2 iResolution;\n"
"\n"
"// Global constants\n"
"const float pi = acos(-1.);\n"
"const vec3 c = vec3(1.0, 0.0, -1.0);\n"
"float a = 1.0;\n"
"\n"
"float sm(float d)\n"
"{\n"
"    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n"
"}\n"
"\n"
"void dlinesegment(in vec2 x, in vec2 p1, in vec2 p2, out float d)\n"
"{\n"
"    vec2 da = p2-p1;\n"
"    d = length(x-mix(p1, p2, clamp(dot(x-p1, da)/dot(da,da),0.,1.)));\n"
"}\n"
"\n"
"void palette1(in float scale, out vec3 col)\n"
"{\n"
"    const int N = 5;\n"
"   \n"
"    //*\n"
"    const vec3 colors[N] = vec3[N](\n"
"            vec3(0.82,0.27,0.13),\n"
"            vec3(0.85,0.77,0.68),\n"
"            vec3(0.65,0.59,0.55),\n"
"            vec3(0.45,0.29,0.24),\n"
"            vec3(0.85,0.27,0.15)\n"
"        );\n"
"    //*/\n"
"    \n"
"    /*\n"
"	const vec3 colors[N] = vec3[N](\n"
"       	vec3(0.86,0.21,0.13),\n"
"        vec3(0.85,0.80,0.62),\n"
"        vec3(0.22,0.25,0.25),\n"
"        vec3(0.16,0.17,0.17),\n"
"        vec3(0.12,0.12,0.13)\n"
"    );\n"
"    //*/\n"
"    \n"
"	/*\n"
"    const vec3 colors[N] = vec3[N](\n"
"       	vec3(0.00,0.00,0.00),\n"
"        vec3(0.64,0.05,0.05),\n"
"        vec3(0.91,0.06,0.05),\n"
"        vec3(0.96,0.82,0.65),\n"
"        vec3(0.65,0.49,0.36)\n"
"    );\n"
"    //*/\n"
"	float index = floor(scale*float(N)), \n"
"        remainder = scale*float(N)-index;\n"
"    col = mix(colors[int(index)],colors[int(index)+1], remainder);\n"
"}\n"
"\n"
"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n"
"{\n"
"    a = iResolution.x/iResolution.y;\n"
"    vec2 uv = fragCoord/iResolution.yy-0.5*vec2(a, 1.0);\n"
"    vec3 col = .1*c.xxx;\n"
"    col = mix(col, .3*c.xxx, sm(-min(abs(mod(uv.x,.01)-.005)-.003,abs(mod(uv.y,.01)-.005)-.003)));\n"
"    \n"
"    float d, d0;\n"
"    dlinesegment(uv, -.25*a*c.xy, .25*a*c.xy, d);\n"
" 	d = abs(d)-.05;\n"
"    col = mix(col, .3*c.xxx, sm(d));\n"
"    d = abs(d)-.001;\n"
"    col = mix(col, c.xxx, sm(d));\n"
"    dlinesegment(uv, -.25*a*c.xy, -.25*a*c.xy+.5*a*iProgress*c.xy, d);\n"
"    d = abs(d)-.045;\n"
"    \n"
"    vec3 c1;\n"
"    palette1(clamp((uv.y+.045)/.15,0.,1.), c1);\n"
"    \n"
"    col = mix(col, c1, sm(d));\n"
"    \n"
"    //col += col;\n"
"    //col *= col;\n"
"    \n"
"    fragColor = vec4(clamp(col,0.,1.),1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    mainImage(gl_FragColor, gl_FragCoord.xy);\n"
"}\n"
"\n"
;
#endif
