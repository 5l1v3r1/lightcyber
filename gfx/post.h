/* Generated with shader-compressor by NR4/Team210. */
#ifndef POST_H
#define POST_H
const char * post_frag =
"/* Endeavor by Team210 - 64k intro by Team210 at Revision 2k19\n"
" * Copyright (C) 2019  Alexander Kraus <nr4@z10.info>\n"
" *\n"
" * This program is free software: you can redistribute it and/or modify\n"
" * it under the terms of the GNU General Public License as published by\n"
" * the Free Software Foundation, either version 3 of the License, or\n"
" * (at your option) any later version.\n"
" *\n"
" * This program is distributed in the hope that it will be useful,\n"
" * but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
" * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
" * GNU General Public License for more details.\n"
" *\n"
" * You should have received a copy of the GNU General Public License\n"
" * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n"
" */\n"
" \n"
"#version 130\n"
"\n"
"uniform float iFSAA;\n"
"uniform vec2 iResolution;\n"
"uniform sampler2D iChannel0;\n"
"uniform float iTime;\n"
"\n"
"out vec4 gl_FragColor;\n"
"\n"
"const float pi = acos(-1.);\n"
"const vec3 c = vec3(1.,0.,-1.);\n"
"\n"
"float nbeats;\n"
"float iScale;\n"
"\n"
"void rand(in vec2 x, out float n)\n"
"{\n"
"    x += 400.;\n"
"    n = fract(sin(dot(sign(x)*abs(x) ,vec2(12.9898,78.233)))*43758.5453);\n"
"}\n"
"\n"
"// Stroke\n"
"void stroke(in float d0, in float s, out float d)\n"
"{\n"
"    d = abs(d0)-s;\n"
"}\n"
"\n"
"float sm(float d)\n"
"{\n"
"    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n"
"}\n"
"\n"
"void rot3(in vec3 p, out mat3 rot)\n"
"{\n"
"    rot = mat3(c.xyyy, cos(p.x), sin(p.x), 0., -sin(p.x), cos(p.x))\n"
"        *mat3(cos(p.y), 0., -sin(p.y), c.yxy, sin(p.y), 0., cos(p.y))\n"
"        *mat3(cos(p.z), -sin(p.z), 0., sin(p.z), cos(p.z), c.yyyx);\n"
"}\n"
"\n"
"void dbox3(in vec3 x, in vec3 b, out float d)\n"
"{\n"
"  vec3 da = abs(x) - b;\n"
"  d = length(max(da,0.0))\n"
"         + min(max(da.x,max(da.y,da.z)),0.0);\n"
"}\n"
"\n"
"void add(in vec2 sda, in vec2 sdb, out vec2 sdf)\n"
"{\n"
"    sdf = mix(sda, sdb, step(sdb.x, sda.x));\n"
"}\n"
"\n"
"mat3 R;\n"
"void scene(in vec3 x, out vec2 sdf)\n"
"{\n"
"    float d;\n"
"    \n"
"	// Big red box    \n"
"    dbox3(x, .2*c.xxx, sdf.x);\n"
"    sdf.y = 1.;\n"
"    \n"
"    // Holes\n"
"    \n"
"    // 2 upper bar\n"
"    dbox3(x-.1*c.xyy, vec3(.02,.3,.12), d);\n"
"    sdf.x = max(-d, sdf.x);\n"
"    sdf.y = mix(sdf.y, 2., step(d, sdf.x));\n"
"    \n"
"    // 2 right bar\n"
"    dbox3(x-.05*c.xyy-.1*c.yyx, vec3(.07,.3,.02), d);\n"
"    sdf.x = max(-d, sdf.x);\n"
"    sdf.y = mix(sdf.y, 2., step(d, sdf.x));\n"
"    \n"
"    // 2 mid bar\n"
"    dbox3(x, vec3(.02,.3,.1), d);\n"
"    sdf.x = max(-d, sdf.x);\n"
"    sdf.y = mix(sdf.y, 2., step(d, sdf.x));\n"
"    \n"
"    // 2 left bar\n"
"    dbox3(x+.05*c.xyy+.1*c.yyx, vec3(.07,.3,.02), d);\n"
"    sdf.x = max(-d, sdf.x);\n"
"    sdf.y = mix(sdf.y, 2., step(d, sdf.x));\n"
"    \n"
"    // 2 dot\n"
"    dbox3(x+.1*c.xyy-.1*c.yyx, vec3(.02,.3,.02), d);\n"
"    sdf.x = max(-d, sdf.x);\n"
"    sdf.y = mix(sdf.y, 2., step(d, sdf.x));\n"
"    \n"
"    // 1 bar\n"
"    dbox3(x+.04*c.yyx, vec3(.3,.02,.08), d);\n"
"    sdf.x = max(-d, sdf.x);\n"
"    sdf.y = mix(sdf.y, 2., step(d, sdf.x));\n"
"    \n"
"    // 1 dot\n"
"    dbox3(x-.1*c.yyx, vec3(.3,.02,.02), d);\n"
"    sdf.x = max(-d, sdf.x);\n"
"    sdf.y = mix(sdf.y, 2., step(d, sdf.x));\n"
"    \n"
"    // 0 big stripes\n"
"    vec3 y = vec3(x.x, abs(x.y), x.z);\n"
"    dbox3(y-.05*c.yxy, vec3(.1,.03,.3), d);\n"
"    sdf.x = max(-d, sdf.x);\n"
"    sdf.y = mix(sdf.y, 2., step(d, sdf.x));\n"
"\n"
"	// 0 small stripes\n"
"    dbox3(y-.1*c.yxy-.06*c.xyy, vec3(.08,.021,.3), d);\n"
"    sdf.x = max(-d, sdf.x);\n"
"    sdf.y = mix(sdf.y, 2., step(d, sdf.x));\n"
"\n"
"    // 0 upper/lower stripes\n"
"    vec3 z = vec3(abs(x.x), x.yz);\n"
"	dbox3(z-.119*c.xyy, vec3(.021,.08,.3), d);\n"
"    sdf.x = max(-d, sdf.x);\n"
"    sdf.y = mix(sdf.y, 2., step(d, sdf.x));\n"
"}\n"
"\n"
"void normal(in vec3 x, out vec3 n, in float dx)\n"
"{\n"
"    vec2 s, na;\n"
"    \n"
"    scene(x,s);\n"
"    scene(x+dx*c.xyy, na);\n"
"    n.x = na.x;\n"
"    scene(x+dx*c.yxy, na);\n"
"    n.y = na.x;\n"
"    scene(x+dx*c.yyx, na);\n"
"    n.z = na.x;\n"
"    n = normalize(n-s.x);\n"
"}\n"
"\n"
"void mainImage( out vec4 fragColor, in vec2 fragCoord_ )\n"
"{\n"
"    vec2 fragCoord = fragCoord_;\n"
"    float a = iResolution.x/iResolution.y;\n"
"    vec2 uv = fragCoord/iResolution.yy-0.5*vec2(a, 1.0);\n"
"    \n"
"    vec3 col = vec3(0.);\n"
"    float delta = 0.;\n"
"//     vec2 n = c.yy;\n"
"    \n"
"    // Box\n"
"    rot3(vec3(-2.*pi/8.,2.*pi/8.,2.*pi/4.)-iTime*vec3(1.1,1.3,1.5), R);\n"
"    \n"
"    float d;\n"
"    vec2 s;\n"
"    vec3 o, r, u, t, size, dir, x, n;\n"
"    vec2 uv2 = 10.*(uv-vec2(-.45*a,.45));\n"
"    o = R * c.yyx;\n"
"	r = c.xyy; \n"
"	u = c.yxy;\n"
"	t = c.yyy; \n"
"    int N = 250,\n"
"        i;\n"
"    t = uv2.x * r + uv2.y * u;\n"
"    t = R * t;\n"
"    dir = normalize(t-o);\n"
"\n"
"    size = .2*c.xxx;\n"
"\n"
"	vec3 tlo = min((size-o)/dir,(-size-o)/dir); // Select 3 visible planes\n"
"    vec2 abxlo = abs(o.yz + tlo.x*dir.yz),\n"
"        abylo = abs(o.xz + tlo.y*dir.xz),\n"
"        abzlo = abs(o.xy + tlo.z*dir.xy);\n"
"\n"
"    vec4 dn = 100.*c.xyyy;\n"
"\n"
"    dn = mix(dn, vec4(tlo.x,c.xyy), float(all(lessThan(abxlo,size.yz)))*step(tlo.x,dn.x));\n"
"    dn = mix(dn, vec4(tlo.y,c.yxy), float(all(lessThan(abylo,size.xz)))*step(tlo.y,dn.x));\n"
"    dn = mix(dn, vec4(tlo.z,c.yyx), float(all(lessThan(abzlo,size.xy)))*step(tlo.z,dn.x));\n"
"    \n"
"    d = dn.r;\n"
"    if(d<=2.)\n"
"    {\n"
"        x = o + d * dir;\n"
"        scene(x,s);\n"
"        \n"
"        if(s.x > 1.e-4)\n"
"        {\n"
"            for(i = 0; i<N; ++i)\n"
"            {\n"
"                x = o + d * dir;\n"
"                scene(x,s);\n"
"                if(s.x < 1.e-4)break;\n"
"                d += s.x;\n"
"            }\n"
"        }\n"
"        \n"
"        if(i<N)\n"
"        {\n"
"            normal(x,n, 5.e-4);\n"
"            \n"
"            if(s.y == 1.)\n"
"            {\n"
"                vec3 l = normalize(x+c.zzx*vec3(1.3,.9,1.2));\n"
"                col = vec3(0.81,0.15,0.18);\n"
"                col = .3*col\n"
"                    + .4*col * abs(dot(l,n))\n"
"                    + .6 * col * abs(pow(dot(reflect(-l,n),dir),2.));\n"
"            }\n"
"            else if(s.y == 2.)\n"
"            {\n"
"                vec3 l = normalize(x+c.zzx*vec3(1.3,.9,1.2));\n"
"                col = .7*c.xxx;\n"
"                col = .5*col\n"
"                    + .4*col * abs(dot(l,n))\n"
"                    + .8 * col * abs(pow(dot(reflect(-l,n),dir),2.));\n"
"            }\n"
"        }\n"
"    }\n"
"    else\n"
"    {\n"
"    /*\n"
"    if(iTime > 66.27 && iTime < 82.76) // blend in to caleidoscope\n"
"    {\n"
"        n = vec2(7.,1.);\n"
"        float phi = abs(mod(atan(uv.y, uv.x),pi/n.x)-.5*pi/n.x);\n"
"        uv = length(uv)*vec2(cos(phi+2.*pi), sin(phi+2.*pi));\n"
"        fragCoord = mix(fragCoord, (uv + .5*vec2(a,1.))*iResolution.yy, smoothstep(66.27,67.27,iTime)*(1.-smoothstep(81.76,82.76,iTime)));\n"
"    }\n"
"    else if(iTime > 120.0 && iTime < 136.0) // blend in to caleidoscope\n"
"    {\n"
"        n = vec2(7.,1.);\n"
"        float phi = abs(mod(atan(uv.y, uv.x),pi/n.x)-.5*pi/n.x);\n"
"        uv = length(uv)*vec2(cos(phi+2.*pi), sin(phi+2.*pi));\n"
"        fragCoord = mix(fragCoord, (uv + .5*vec2(a,1.))*iResolution.yy, smoothstep(120.,121.,iTime)*(1.-smoothstep(135.,136.,iTime)));\n"
"    }*/\n"
"    \n"
"        float bound = sqrt(iFSAA)-1.;\n"
"    //     bound = mix(bound, 4., smoothstep(66.27,67.27,iTime)*(1.-smoothstep(81.76,82.76,iTime)));\n"
"        \n"
"        //if((iTime > 66.27 && iTime < 82.76) || (iTime > 120.0 && iTime < 136.0))\n"
"        if(iTime > 0.)\n"
"        {\n"
"            for(float i = -.5*bound; i<=.5*bound; i+=1.)\n"
"                for(float j=-.5*bound; j<=.5*bound; j+=1.)\n"
"                {\n"
"                    col += texture(iChannel0, fragCoord/iResolution.xy+vec2(i,j)*3./max(bound, 1.)/iResolution.xy).xyz;\n"
"                }\n"
"            col /= iFSAA;\n"
"        }\n"
"        else\n"
"        {\n"
"            for(float i = -.5*bound; i<=.5*bound; i+=1.)\n"
"                for(float j=-.5*bound; j<=.5*bound; j+=1.)\n"
"                {\n"
"                    col += texture(iChannel0, fragCoord/iResolution.xy+vec2(i,j)*mix(3.,15.,2.*abs(fragCoord.y/iResolution.y-.5))*exp(-abs(1.e-2*length(fragCoord.xy)/iResolution.y-.5))/max(bound, 1.)/iResolution.xy).xyz;\n"
"                }\n"
"            col /= iFSAA;\n"
"        }\n"
"    }\n"
"    \n"
"    // Scan lines\n"
"    col += vec3(0., 0.05, 0.1)*sin(uv.y*1050.+ 5.*iTime);\n"
"    \n"
"    fragColor = vec4(col,1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    mainImage(gl_FragColor, gl_FragCoord.xy);\n"
"}\n"
"\n"
;
#endif
